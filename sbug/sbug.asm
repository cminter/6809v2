	NAM SBUG18 MP-09 MONITOR

* MONITOR PROGRAM FOR THE SOUTHWEST TECHNICAL
* PRODUCTS MP-09 CPU BOARD AS COMMENTED BY....

* ALLEN CLARK            WALLACE WATSON
* 2502 REGAL OAKS LANE   4815 EAST 97th AVE.
* LUTZ, FLA. 33549       TEMPLE TERRACE, FLA. 33617
* PH. 813-977-0347       PH. 813-985-1359

* MODIFIED TO SBUG09 VER 1.8 BY:  RANDY JARRETT
*                                 2561 NANTUCKET DR APT. E
*                                 ATLANTA, GA  30345
*                                 PH. 404-320-1043

* PORTED TO 6809v2 VER 1.0 BY:    David Wood
*                                 jbevren@gmail.com


*       *** COMMANDS ***

* CONTROL A   = ALTER THE "A" ACCUMULATOR
* CONTROL B   = ALTER THE "B" ACCUMULATOR
* CONTROL C   = ALTER THE CONDITION CODE REGISTER
* CONTROL D   = ALTER THE DIRECT PAGE REGISTER
* CONTROL P   = ALTER THE PROGRAM COUNTER
* CONTROL U   = ALTER USER STACK POINTER
* CONTROL X   = ALTER "X" INDEX REGISTER
* CONTROL Y   = ALTER "Y" INDEX REGISTER
* B hhhh      = SET BREAKPOINT AT LOCATION $hhhh
* E ssss-eeee = EXAMINE MEMORY FROM STARTING ADDRESS ssss
*              -TO ENDING ADDRESS eeee.
* G           = CONTINUE EXECUTION FROM BREAKPOINT OR SWI
* I ssssss hhhh = Load sector ssssssss to memory hhhh (512 byes)
* K           = DISPLAY STACK FROM ssss TO $DFC0
* L           = LOAD TAPE
* M hhhh      = EXAMINE AND CHANGE MEMORY LOCATION hhhh
* O ssssss hhhh = Write memory hhhh to sector ssssssss (512 bytes)
* P ssss-eeee = PUNCH TAPE, START ssss TO END eeee ADDR.
* Q ssss-eeee = TEST MEMORY FROM ssss TO eeee
* R           = DISPLAY REGISTER CONTENTS
* S           = Load S19 file to memory (just dump S19 file to console)
* U           = Boot from partition nn (n=0-4; 0=load&exec sector 0)
* V           = Setup SD card and view partition table (USES MEMORY D000-D1FF)
* X           = REMOVE ALL BREAKPOINTS


TSTPAT EQU $55AA  TEST PATTERN



	ORG $DFC0
STACK  RMB 2  TOP OF INTERNAL STACK / USER VECTOR
SWI3   RMB 2  SOFTWARE INTERRUPT VECTOR #3
SWI2   RMB 2  SOFTWARE INTERRUPT VECTOR #2
FIRQ   RMB 2  FAST INTERRUPT VECTOR
IRQ    RMB 2  INTERRUPT VECTOR
SWI    RMB 2  SOFTWARE INTERRUPT VECTOR
SVCVO  RMB 2  SUPERVISOR CALL VECTOR ORGIN
SVCVL  RMB 2  SUPERVISOR CALL VECTOR LIMIT
CPORT  RMB 2  RE-VECTORABLE CONTROL PORT
ECHO   RMB 1  ECHO FLAG
BPTBL  RMB 24 BREAKPOINT TABLE BASE ADDR

* 68681 registers
DUART	EQU $ff00    * DUART at FF00-FF0F
MR1A	EQU 0  * r/w
MR2A	EQU 0  * r/w
SRA	EQU 1  * read
CSRA	EQU 1  * write
BRGTEST EQU 2  * read
CRA	EQU 2  * write
RHRA	EQU 3  * read
THRA	EQU 3  * write
IPCR	EQU 4  * read
ACR	EQU 4  * write
ISR	EQU 5  * read
IMR	EQU 5  * write
CTU	EQU 6  * read
CTUR	EQU 6  * write
CTL	EQU 7  * read
CTLR	EQU 7  * write
MR1B	EQU 8  * r/w
MR2B	EQU 8  * r/w
SRB	EQU 9  * read
CSRB	EQU 9  * write
X16TEST	EQU 10 * read
CRB	EQU 10 * write
RHRB	EQU 11 * read
THRB	EQU 11 * write
IVR	EQU 12 * r/w
IP	EQU 13 * read
OPCR	EQU 13 * write
CNTGO	EQU 14 * read
SOPR	EQU 14 * write
CNTSTP	EQU 15 * read
ROPR	EQU 15 * write



*IC11   EQU $FFF0  DAT RAM CHIP

	ORG $F800
	FDB MONITOR	Restart monitor
	FDB NEXTCMD	Get next monitor command
	FDB INCH	Input char
	FDB INCHE	Input char with echo
	FDB INCHEK	Input Check for character
	FDB OUTCH	Output Character
	FDB PDATA	Print ctrl-d terminated string
	FDB PCRLF	Print CRLF
	FDB PSTRNG	Print string preceded by CRLF
	FDB MONITOR	Restart monitor (deprecated syscall)
*FDB BLKREAD	Read mass storage sector to memory (new)
*FDB BLKWRITE	Write mass storage sector from memory (new)

* MASS STORAGE to use sdcard in 6809v2.
* sdcard (block dev) access:
* sdcard wants
*  cmd: 17=read, 24=write
*  data: 32bit sector address (sdhc) or byte offset (sd)
*        (translate to sector addresses all times via monitor)
* INPUT:
* stack: LBA (32 bits/4 bytes)
* X reg: data pointer
* RETURNS:
* carry set if error
*
* Firmware will init the sdcard when partition table is viewed.

* MONITOR

MONITOR LDX  #RAMVEC POINT TO VECTOR ADDR. STRING
	LDY  #STACK POINT TO RAM VECTOR LOCATION
	LDB  #$10 BYTES TO MOVE = 16
LOOPA	LDA  ,X+ GET VECTOR BYTE
	STA  ,Y+   PUT VECTORS IN RAM / $DFC0-$DFCF
	DECB SUBTRACT 1 FROM NUMBER OF BYTES TO MOVE
	BNE  LOOPA CONTINUE UNTIL ALL VECTORS MOVED

	LDX  #DUART       GET CONTROL PORT ADDR.
	STX  CPORT        STORE ADDR. IN RAM
	LBSR XBKPNT       CLEAR OUTSTANDING BREAKPOINTS
	LDB  #12          CLEAR 12 BYTES ON STACK
CLRSTK  CLR  ,-S
	DECB
	BNE  CLRSTK
	LEAX MONITOR,PCR  SET PC TO SBUG-E ENTRY
	STX  10,S         ON STACK
	LDA  #$D0         PRESET CONDITION CODES ON STACK
	STA  ,S
	TFR  S,U
	LBSR CONINIZ      INITIALIZE CONTROL PORT
	LDX  #MSG1        POINT TO 'SBUG 1.8' MESSAGE
	LBSR PDATA        PRINT MSG


***** NEXTCMD *****

NEXTCMD LDX  #MSG3        POINT TO MSG ">"
	LBSR PSTRNG       PRINT MSG
	LBSR INCH         GET ONE CHAR. FROM TERMINAL
	ANDA #$7F         STRIP PARITY FROM CHAR.
	CMPA #$0D         IS IT CARRIAGE RETURN ?
	BEQ  NEXTCMD      IF CR THEN GET ANOTHER CHAR.
	TFR  A,B          PUT CHAR. IN "B" ACCUM.
	CMPA #$20         IS IT CONTROL OR DATA CHAR ?
	BGE  PRTCMD       IF CMD CHAR IS DATA, PRNT IT
	LDA  #'^          ELSE CNTRL CHAR CMD SO...
	LBSR OUTCH        PRINT "^"
	TFR  B,A          RECALL CNTRL CMD CHAR
	ADDA #$40         CONVERT IT TO ASCII LETTER
PRTCMD	LBSR OUTCH        PRNT CMD CHAR
	LBSR OUT1S        PRNT SPACE
	CMPB #$60
	BLE  NXTCH0
	SUBB #$20


***** DO TABLE LOOKUP *****
*   FOR COMMAND FUNCTIONS

NXTCH0	LDX  #JMPTAB      POINT TO JUMP TABLE
NXTCHR	CMPB ,X+          DOES COMMAND MATCH TABLE ENTRY ?
	BEQ  JMPCMD       BRANCH IF MATCH FOUND
	LEAX 2,X          POINT TO NEXT ENTRY IN TABLE
	CMPX #TABEND      REACHED END OF TABLE YET ?
	BNE  NXTCHR       IF NOT END, CHECK NEXT ENTRY
	LDX  #MSG4        POINT TO MSG "WHAT?"
	LBSR PDATA        PRINT MSG
	BRA  NEXTCMD      IF NO MATCH, PRMPT FOR NEW CMD
JMPCMD	JSR  [,X]         JUMP TO COMMAND ROUTINE
	BRA  NEXTCMD      PROMPT FOR NEW COMMAND


* "G" GO OR CONTINUE

GO	TFR  U,S
RTI	RTI


* "R" DISPLAY REGISTERS

REGSTR	LDX  #MSG5        POINT TO MSG " - "
	LBSR PSTRNG       PRINT MSG
	LBSR PRTSP
	LBSR PRTUS
	LBSR PRTDP
	LBSR PRTIX
	LBSR PRTIY
	LDX  #MSG5        POINT TO MSG " - "
	LBSR PSTRNG       PRINT MSG
	LBSR PRTPC
	LBSR PRTA
	LBSR PRTB
	LBRA PRTCC


* ALTER "PC" PROGRAM COUNTER


ALTRPC LBSR PRTPC $FCF5 PRINT MSG " PC = "
	LBSR OUT1S OUTPUT SPACE
	LBSR IN1ADR GET NEW CONTENTS FOR "PC"
	BVS  ALTPCD EXIT IF INVALID HEX
	STX  10,U POKE IN NEW CONTENTS
ALTPCD RTS


* ALTER "U" USER STACK POINTER


ALTRU LBSR PRTUS $FCCA PRINT MSG " US = "
	LBSR OUT1S OUTPUT SPACE
	LBSR IN1ADR
	BVS  ALTUD
	STX  8,U
ALTUD RTS


*
* ALTER "Y" INDEX REGISTER


ALTRY LBSR PRTIY PRINT MSG " IY = "
	LBSR OUT1S OUTPUT SPACE
	LBSR IN1ADR
	BVS  ALTYD
	STX  6,U   $F8F0
ALTYD RTS


* ALTER "X" INDEX REGISTER


ALTRX LBSR PRTIX $FCE0 PRINT MSG " IX = "
	LBSR OUT1S OUTPUT SPACE
	LBSR IN1ADR
	BVS  ALTXD
	STX  4,U
ALTXD RTS


* ALTER "DP" DIRECT PAGE REGISTER


ALTRDP LBSR PRTDP $FCD5 PRINT MSG " DP = "
	LBSR OUT1S OUTPUT SPACE
	LBSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS  ALTDPD
	STA  3,U
ALTDPD RTS


* ALTER "B" ACCUMULATOR


ALTRB LBSR PRTB $FD09 PRINT MSG " B = "
	LBSR OUT1S OUTPUT SPACE
	LBSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS  ALTBD
	STA  2,U
ALTBD RTS       $F91C


* ALTER "A" ACCUMULATOR

ALTRA LBSR PRTA $FCFF RINT MSG " A = "
	LBSR OUT1S OUTPUT SPACE
	LBSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS  ALTAD
	STA  1,U
ALTAD RTS


* ALTER "CC" REGISTER

ALTRCC LBSR PRTCC $FD13 PRINT MSG " CC: "
	LBSR OUT1S OUTPUT SPACE
	LBSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS  ALTCCD
	ORA  #$80 SETS "E" FLAG IN PRINT LIST
	STA  ,U
ALTCCD RTS


***** "M" MEMORY EXAMINE AND CHANGE *****

MEMCHG LBSR IN1ADR  INPUT ADDRESS
	BVS  CHRTN  IF NOT HEX, RETURN
	TFR  X,Y SAVE ADDR IN "Y"
MEMC2 LDX  #MSG5 POINT TO MSG " - "
	LBSR PSTRNG PRINT MSG
	TFR  Y,X FETCH ADDRESS
	LBSR OUT4H PRINT ADDR IN HEX
	LBSR OUT1S OUTPUT SPACE
	LDA  ,Y GET CONTENTS OF CURRENT ADDR.
	LBSR OUT2H OUTPUT CONTENTS IN ASCII
	LBSR OUT1S OUTPUT SPACE
	LBSR BYTE LOOP WAITING FOR OPERATOR INPUT
	BVC  CHANGE IF VALID HEX GO CHANGE MEM. LOC.
	CMPA #8  IS IT A BACKSPACE (CNTRL H)?
	BEQ  MEMC2 PROMPT OPERATOR AGAIN
	CMPA #$18  IS IT A CANCEL (CNTRL X)?
	BEQ  MEMC2 PROMPT OPERATOR AGAIN
	CMPA #'^  IS IT AN UP ARROW?
	BEQ  BACK  DISPLAY PREVIOUS BYTE
	CMPA #$D  IS IT A CR?
	BNE  FORWRD  DISPLAY NEXT BYTE
CHRTN RTS EXIT ROUTINE

CHANGE STA ,Y  CHANGE BYTE IN MEMORY
	CMPA ,Y  DID MEMORY BYTE CHANGE?
	BEQ  FORWRD    $F972
	LBSR OUT1S OUTPUT SPACE
	LDA  #'?  LOAD QUESTION MARK
	LBSR OUTCH  PRINT IT
FORWRD LEAY 1,Y POINT TO NEXT HIGHER MEM LOCATION
	BRA  MEMC2 PRINT LOCATION & CONTENTS
BACK LEAY -1,Y POINT TO LAST MEM LOCATION
	BRA  MEMC2 PRINT LOCATION & CONTENTS


* "K" DISPLAY STACK ('S' command replaced with S19 load)
* HEX-ASCII DISPLAY OF CURRENT STACK CONTENTS FROM
* CURRENT STACK POINTER TO INTERNAL STACK LIMIT.

DISSTK LBSR PRTSP PRINT CURRENT STACK POINTER
	TFR  U,Y
	LDX  #STACK LOAD INTERNAL STACK AS UPPER LIMIT
	LEAX -1,X POINT TO CURRENT STACK
	BRA  MDUMP1 ENTER MEMORY DUMP OF STACK CONTENTS


* "E" DUMP MEMORY FOR EXAMINE IN HEX AND ASCII
* AFTER CALLING 'IN2ADR' LOWER ADDRESS IN Y-REG.
*                        UPPER ADDRESS IN X-REG.
* IF HEX ADDRESSES ARE INVALID (V)=1.

MEMDUMP LBSR IN2ADR INPUT ADDRESS BOUNDRIES
	BVS  EDPRTN NEW COMMAND IF ILLEGAL HEX
MDUMP1 PSHS Y COMPARE LOWER TO UPPER BOUNDS
	CMPX ,S++ LOWER BOUNDS > UPPER BOUNDS?
	BCC  AJDUMP IF NOT, DUMP HEX AND ASCII
EDPRTN RTS

* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDRIES.

* IF LOWER ADDR = $4532
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530.

* IF UPPER ADDR = $4567
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570.

* ENTER WITH LOWER ADDRESS IN X-REG.
*           -UPPER ADDRESS ON TOP OF STACK.

AJDUMP TFR  X,D GET UPPER ADDR IN D-REG
	ADDD #$10 ADD 16 TO UPPER ADDRESS
	ANDB #$F0 MASK TO EVEN 16 BYTE BOUNDRY
	PSHS A,B SAVE ON STACK AS UPPER DUMP LIMIT
	TFR  Y,D   $F9A5 GET LOWER ADDRESS IN D-REG
	ANDB #$F0 MASK TO EVEN 16 BYTE BOUNDRY
	TFR  D,X PUT IN X-REG AS LOWER DUMP LIMIT
NXTLIN CMPX ,S COMPARE LOWER TO UPPER LIMIT
	BEQ  SKPDMP IF EQUAL SKIP HEX-ASCII DUMP
	LBSR INCHEK CHECK FOR INPUT FROM KEYBOARD
	BEQ  EDUMP IF NONE, CONTINUE WITH DUMP
SKPDMP LEAS 2,S READJUST STACK IF NOT DUMPING
	RTS

* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS.

EDUMP PSHS X PUSH LOWER ADDR LIMIT ON STACK
	LDX  #MSG5 POINT TO MSG " - "
	LBSR PSTRNG PRINT MSG
	LDX  ,S LOAD LOWER ADDR FROM TOP OF STACK
	LBSR OUT4H PRINT THE ADDRESS 
	LBSR OUT2S PRINT 2 SPACES
	LDB  #$10 LOAD COUNT OF 16 BYTES TO DUMP
ELOOP LDA  ,X+ GET FROM MEMORY HEX BYTE TO PRINT
	LBSR OUT2H OUTPUT HEX BYTE AS ASCII
	LBSR OUT1S OUTPUT SPACE
	DECB      $F9D1 DECREMENT BYTE COUNT
	BNE  ELOOP CONTINUE TIL 16 HEX BYTES PRINTED

* PRINT 16 ASCII CHARACTERS
* IF NOT PRINTABLE OR NOT VALID
* ASCII PRINT A PERIOD (.)
	LBSR OUT2S 2 SPACES
	LDX  ,S++ GET LOW LIMIT FRM STACK - ADJ STACK
	LDB  #$10 SET ASCII CHAR TO PRINT = 16
EDPASC LDA  ,X+ GET CHARACTER FROM MEMORY
	CMPA #$20 IF LESS THAN $20, NON-PRINTABLE?
	BCS  PERIOD IF SO, PRINT PERIOD INSTEAD
	CMPA #$7E IS IT VALID ASCII?
	BLS  PRASC IF SO PRINT IT
PERIOD LDA  #'. LOAD A PERIOD (.)
PRASC LBSR OUTCH PRINT ASCII CHARACTER
	DECB DECREMENT COUNT
	BNE  EDPASC
	BRA  NXTLIN


***** "Q" MEMORY TEST *****

MEMTST CLR  ,-S CLEAR BYTE ON STACK
	CLR  ,-S CLEAR ANOTHER BYTE
	LBSR IN2ADR GET BEGIN(Y) & END(X) ADDR. LIMITS
	PSHS X,Y SAVE ADDRESSES ON STACK
	BVS  ADJSK6 EXIT IF NOT VALID HEX
	CMPX 2,S COMPARE BEGIN TO END ADDR.
	BCS  ADJSK6 EXIT IF BEGIN > END ADDR.
	LBSR OUT1S OUTPUT SPACE
MEMSET TFR  Y,D PUT BEGIN ADDR. IN 'D'-ACCUM.
	ADDD 4,S ADD PASS COUNT TO BEGIN ADDR
	PSHS B ADD LS BYTE TO MS BYTE OF BEGIN ADDR
	ADDA ,S+
	STA  ,Y+ SAVE THIS DATA BYTE AT BEGIN ADDR
	CMPY ,S COMPARE END TO BEGIN ADDR
	BCS  MEMSET IF BEGIN LOWER, CONTINUE TO SET MEMORY
	LDY  2,S RELOAD BEGIN ADDRESS
TEST1 TFR  Y,D PUT BEGIN ADDR IN 'D'-ACC.
	ADDD 4,S ADD PASS COUNT TO ADDRESS
	PSHS A ADD MS BYTE TO LS BYTE OF ADDRESS
	ADDB ,S+
	EORB ,Y+ EX-OR THIS DATA WITH DATA IN MEMORY LOC.
	BEQ  GUDPAS IF (Z) SET, MEMORY BYTE OK
	LDX  #MSG5 POINT TO MSG " - "
	LBSR PSTRNG PRINT MSG
	LEAX -1,Y GET ERROR ADDRESS IN X-REG
	LBSR OUT4H OUTPUT IT
	PSHS X PUSH ERROR ADDR ON STACK
	LDX  #MSG8  POINT TO MSG " =>"
	LBSR PDATA  PRINT MSG
	PULS X POP ERROR ADDR FROM STACK
	LBSR OUT4H OUTPUT LS 16 BITS OF PHYSICAL ADDR
	LDX  #MSG6  POINT TO MSG ", PASS "
	LBSR PDATA  PRINT MSG
	LDX  4,S LOAD PASS COUNT
	LBSR OUT4H OUTPUT IT
	LDX  #MSG7 POINT TO MSG ", BITS IN ERROR
	LBSR PDATA  PRINT MSG
	TFR  B,A GET ERROR BYTE INTO A-ACC
	LDX  #MSG9 POINT TO MSG "76543210"
	LBSR BIASCI OUTPUT IN BINARY/ASCII FORMAT
	LBSR INCHEK CHECK FOR INPUT FROM KEYBOARD $FA56
	BNE  ADJSK6 IF SO, EXIT MEMORY TEST
GUDPAS CMPY ,S COMPARE END ADDR TO BEGIN ADDR
	BCS  TEST1
	LDA  #'+ GET "PASS" SYMBOL IF MEMORY PASS OK
	LBSR OUTCH OUTPUT SYMBOL TO TERMINAL
	LBSR INCHEK INPUT FROM KEYBOARD?
	BNE  ADJSK6 IF SO, EXIT MEMORY TEST
	LDY  2,S LOAD BEGIN ADDRESS
	INC  5,S INCREMENT LS BYTE OF PASS COUNT
	BNE  MEMSET IF NOT ZERO, SET NEXT MEMORY BYTE
	INC  4,S INCREMENT MS BYTE OF PASS COUNT
	BNE  MEMSET DONE WITH 65,535 PASSES OF MEMORY?
ADJSK6 LEAS 6,S ADJ STACK POINTER BY 6
	RTS


***** "B" SET BREAKPOINT *****

BRKPNT LBSR IN1ADR GET BREAKPOINT ADDRESS
	BVS  EXITBP EXIT IF INVALID HEX ADDR.
	CMPX #STACK ADDRESS ILLEGAL IF >=$DFC0
	BCC  BPERR IF ERROR PRINT (?), EXIT
	PSHS X $FA82 PUSH BP ADDRESS ON STACK
	LDX  #$FFFF LOAD DUMMY ADDR TO TEST BP TABLE
	BSR BPTEST TEST BP TABLE FOR FREE SPACE
	PULS X POP BP ADDRESS FROM STACK
	BEQ  BPERR (Z) SET, OUT OF BP TABLE SPACE
	LDA  ,X GET DATA AT BREAKPOINT ADDRESS
	CMPA #$3F IS IT A SWI?
	BEQ  BPERR IF SWI ALREADY, INDICATE ERROR
	STA  ,Y+ SAVE DATA BYTE IN BP TABLE
	STX  ,Y SAVE BP ADDRESS IN BP TABLE
	LDA  #$3F LOAD A SWI ($3F)
	STA  ,X SAVE SWI AT BREAKPOINT ADDRESS
EXITBP RTS

*  INDICATE ERROR SETTING BREAKPOINT

BPERR LBSR OUT1S OUTPUT SPACE
	LDA  #'? LOAD (?), INDICATE BREAKPOINT ERROR
	LBRA OUTCH PRINT "?"


*** "X" CLEAR OUTSTANDING BREAKPOINTS ***

XBKPNT LDY  #BPTBL POINT TO BREAKPOINT TABLE
	LDB  #8 LOAD BREAKPOINT COUNTER
XBPLP BSR RPLSWI REMOVE USED ENTRY IN BP TABLE
	DECB  $FAAC DECREMENT BP COUNTER
	BNE XBPLP END OF BREAKPOINT TABLE?
	RTS


***** SWI ENTRY POINT *****

SWIE TFR  S,U TRANSFER STACK TO USER POINTER
	LDX  10,U LOAD PC FROM STACK INTO X-REG
	LEAX -1,X ADJUST ADDR DOWN 1 BYTE.
	BSR BPTEST FIND BREAKPOINT IN BP TABLE
	BEQ  REGPR IF FOUND, REPLACE DATA AT BP ADDR
	STX  10,U SAVE BREAKPOINT ADDR IN STACK
	BSR RPLSWI GO REPLACE SWI WITH ORIGINAL DATA
REGPR LBSR REGSTR GO PRINT REGISTERS
	LBRA NEXTCMD GET NEXT COMMAND
RPLSWI LDX  1,Y LOAD BP ADDRESS FROM BP TABLE
	CMPX #STACK COMPARE TO TOP AVAILABLE USER MEMORY
	BCC  FFSTBL GO RESET TABLE ENTRY TO $FF'S
	LDA  ,X GET DATA FROM BP ADDRESS
	CMPA #$3F IS IT SWI?
	BNE  FFSTBL IF NOT, RESET TABLE ENTRY TO $FF'S
	LDA  ,Y GET ORIGINAL DATA FROM BP TABLE
	STA  ,X      $FAD3 RESTORE DATA AT BP ADDRESS
FFSTBL LDA  #$FF LOAD $FF IN A-ACC
	STA  ,Y+ RESET BREAKPOINT TABLE DATA TO $FF'S
	STA  ,Y+ RESET BREAKPOINT TABLE ADDR TO $FF'S
	STA  ,Y+
	RTS

** SEARCH BREAKPOINT TABLE FOR MATCH **

BPTEST LDY  #BPTBL POINT TO BREAKPOINT TABLE
	LDB  #8 LOAD BREAKPOINT COUNTER
FNDBP LDA  ,Y+ LOAD DATA BYTE
	CMPX ,Y++ COMPARE ADDRESS, IS IT SAME?
	BEQ  BPADJ IF SO, ADJUST POINTER FOR TABLE ENTRY
	DECB IF NOT, DECREMENT BREAKPOINT COUNTER
	BNE  FNDBP AND LOOK FOR NEXT POSSIBLE MATCH
	RTS

BPADJ LEAY -3,Y MOVE POINTER TO BEGIN OF BP ENTRY
	RTS


***** "L" LOAD MIKBUG TAPE *****

LOAD LDA  #$11  LOAD 'DC1' CASS. READ ON CODE
	LBSR OUTCH  OUTPUT IT TO TERMINAL PORT
	CLR  ECHO  TURN OFF ECHO FLAG
LOAD1 LBSR ECHON INPUT 8 BIT BYTE WITH NO ECHO
LOAD2 CMPA #'S IS IT AN "S", START CHARACTER ?
	BNE  LOAD1 IF NOT, DISCARD AND GET NEXT CHAR.
LOADS LBSR ECHON
	CMPA #'9 IS IT A "9" , END OF FILE CHAR ?
	BEQ  LOAD21 IF SO, EXIT LOAD
	CMPA #'1 IS IT A "1" , FILE LOAD CHAR ?
	BNE  LOAD2 IF NOT, LOOK FOR START CHAR.
	LBSR BYTE INPUT BYTE COUNT
	PSHS A PUSH COUNT ON STACK
	BVS  LODERR (V) C-CODE SET, ILLEGAL HEX
	LBSR IN1ADR INPUT LOAD ADDRESS
	BVS  LODERR (V) C-CODE SET, ADDR NOT HEX
	PSHS X PUSH ADDR ON STACK
	LDB  ,S+ LOAD MSB OF ADDR AS CHECKSUM BYTE
	ADDB ,S+ ADD LSB OF ADDR TO CHECKSUM
	ADDB ,S ADD BYTE COUNT BYTE TO CHECKSUM
	DEC  ,S $FC37 DECREMENT BYTE COUNT 2 TO BYPASS
	DEC  ,S ADDRESS BYTES.
LOAD10 PSHS B PUSH CHECKSUM ON STACK
	LBSR BYTE INPUT DATA BYTE (2 HEX CHAR)
	PULS B POP CHECKSUM FROM STACK
	BVS  LODERR (V) SET, DATA BYTE NOT HEX
	PSHS A PUSH DATA BYTE ON STACK
	ADDB ,S+ ADD DATA TO CHECKSUM, AUTO INC STACK
	DEC  ,S DECREMENT BYTE COUNT 1
	BEQ  LOAD16 IF BYTE COUNT ZERO, TEST CHECKSUM
	STA  ,X+ SAVE DATA BYTE IN MEMORY
	BRA  LOAD10 GET NEXT DATA BYTE
LODERR CLRB ERROR CONDITION, ZERO CHECKSUM
LOAD16 PULS A ADJUST STACK (REMOVE BYTE COUNT)
	CMPB #$FF CHECKSUM OK?
	BEQ  LOAD IF SO, LOAD NEXT LINE
	LDA  #'? LOAD (?) ERROR INDICATOR
	LBSR OUTCH OUTPUT IT TO TERMINAL
LOAD21 COM  ECHO TURN ECHO ON
	LDA  #$13   $FC5F LOAD 'DC3' CASS. READ OFF CODE
	LBRA OUTCH OUTPUT IT


***** "P" PUNCH MIKBUG TAPE *****

PUNCH CLR  ,-S CLEAR RESERVED BYTE ON STACK
	LBSR IN2ADR GET BEGIN AND END ADDRESS
	PSHS X,Y SAVE ADDRESSES ON STACK
	BVS  PUNEXT (V) C-CODE SET, EXIT PUNCH
	CMPX 2,S COMPARE BEGIN TO END ADDR
	BCS  PUNEXT IF BEGIN GREATER THAN END, EXIT PUNCH
	LEAX 1,X INCREMENT END ADDRESS
	STX  ,S STORE END ADDR ON STACK
	LDA  #$12 LOAD 'DC2' PUNCH ON CODE
	LBSR OUTCH OUTPUT IT TO TERMINAL
PUNCH2 LDD  ,S LOAD END ADDR IN D-ACC
	SUBD 2,S SUBTRACT BEGIN FROM END
	BEQ  PUNCH3 SAME, PUNCH 32 BYTES DEFAULT
	CMPD #$20 LESS THAN 32 BYTES?
	BLS  PUNCH4 PUNCH THAT MANY BYTES
PUNCH3 LDB  #$20 LOAD BYTE COUNT OF 32.
PUNCH4 STB  4,S STORE ON STACK AS BYTE COUNT
	LDX  #MSG20 POINT TO MSG "S1"
	LBSR PSTRNG PRINT MSG
	ADDB #3 ADD 3 BYTES TO BYTE COUNT
	TFR  B,A GET BYTE COUNT IN A-ACC TO PUNCH
	LBSR OUT2H OUTPUT BYTE COUNT
	LDX  2,S LOAD BEGIN ADDRESS
	LBSR OUT4H PUNCH ADDRESS
	ADDB 2,S ADD ADDR MSB TO CHECKSUM
	ADDB 3,S ADD ADDR LSB TO CHECKSUM
PUNCHL ADDB ,X ADD DATA BYTE TO CHECKSUM
	LDA  ,X+ LOAD DATA BYTE TO PUNCH
	LBSR OUT2H OUTPUT DATA BYTE
	DEC  4,S DECREMENT BYTE COUNT
	BNE  PUNCHL NOT DONE, PUNCH NEXT BYTE
	COMB 1's COMPLIMENT CHECKSUM BYTE
	TFR  B,A GET IT IN A-ACC TO PUNCH
	LBSR OUT2H OUTPUT CHECKSUM BYTE
	STX  2,S SAVE X-REG IN STACK AS NEW PUNCH ADDR
	CMPX ,S COMPARE IT TO END ADDR
	BNE  PUNCH2      $FCB5 PUNCH NOT DONE, CONT.
PUNEXT LDA  #$14 LOAD 'DC4' PUNCH OFF CODE
	LBSR OUTCH OUTPUT IT
	LEAS 5,S READJUST STACK POINTER
	RTS

*** Print register contents

PRTSP LDX  #MSG10 POINT TO MSG "SP="
	LBSR PDATA  PRINT MSG
	TFR  U,X
	LBRA OUT4H
PRTUS LDX  #MSG12 POINT TO MSG "US="
	LBSR PDATA  PRINT MSG
	LDX  8,U
	LBRA OUT4H
PRTDP LDX  #MSG15 POINT TO MSG "DP="
	LBSR PDATA  PRINT MSG
	LDA  3,U
	LBRA OUT2H OUTPUT HEX BYTE AS ASCII
PRTIX LDX  #MSG14 POINT TO MSG "IX="
	LBSR PDATA  PRINT MSG
	LDX  4,U      $FCE6
	LBRA OUT4H
PRTIY LDX  #MSG13 POINT TO MSG "IY="
	LBSR PDATA  PRINT MSG
	LDX  6,U
	LBRA  OUT4H
PRTPC LDX  #MSG11 POINT TO MSG "PC="
	LBSR PDATA  PRINT MSG
	LDX  10,U
	BRA  OUT4H
PRTA LDX  #MSG16 POINT TO MSG "A="
	LBSR PDATA  PRINT MSG
	LDA  1,U
	BRA OUT2H OUTPUT HEX BYTE AS ASCII
PRTB LDX  #MSG17 POINT TO MSG "B="
	LBSR PDATA  PRINT MSG
	LDA  2,U
	BRA OUT2H OUTPUT HEX BYTE AS ASCII
PRTCC LDX  #MSG18 POINT TO MSG "CC:"
	LBSR PDATA  PRINT MSG
	LDA  ,U
	LDX  #MSG19 POINT TO MSG "EFHINZVC"
	BRA BIASCI OUTPUT IN BINARY/ASCII FORMAT


* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT TWO VALID HEX ADDRESSES.
* THE FIRST ADDRESS INPUT IS RETURNED IN "IY".
* THE SECOND IS RETURNED IN "IX". THE "V" BIT
* IN THE C-CODE REG. IS SET IF AN INVALID HEX
* ADDRESS IS INPUT.

IN2ADR BSR IN1ADR GET FIRST ADDRESS
	BVS NOTHEX EXIT IF NOT VALID HEX
	TFR  X,Y SAVE FIRST ADDR. IN "IY"
	LDA #'-
	LBSR OUTCH PRINT " - "

* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE
* ADDRESS IS RETURNED IN THE "X" REGISTER.

IN1ADR BSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS NOTHEX EXIT IF NOT VALID HEX
	TFR  D,X
	BSR BYTE INPUT BYTE (2 HEX CHAR)
	BVS NOTHEX
	PSHS X
	STA  1,S
	PULS X
	RTS


***** INPUT BYTE (2 HEX CHAR.) *****

BYTE BSR INHEX GET HEX LEFT
	BVS NOTHEX EXIT IF NOT VALID HEX
	ASLA
	ASLA
	ASLA SHIFT INTO LEFT NIBBLE
	ASLA
	TFR  A,B PUT HEXL IN "B"
	BSR INHEX GET HEX RIGHT
	BVS NOTHEX EXIT IF NOT VALID HEX
	PSHS B PUSH HEXL ON STACK
	ADDA ,S+ ADD HEXL TO HEXR AND ADJ. STK
	RTS RETURN WITH HEX L&R IN "A"

INHEX BSR ECHON INPUT ASCII CHAR.
	CMPA #'0 IS IT > OR = "0" ?
	BCS NOTHEX IF LESS IT AIN'T HEX
	CMPA #'9 IS IT < OR = "9" ?
	BHI INHEXA IF > MAYBE IT'S ALPHA
	SUBA #$30 ASCII ADJ. NUMERIC
	RTS

INHEXA CMPA #'A IS IT > OR = "A"
	BCS NOTHEX IF LESS IT AIN'T HEX
	CMPA #'F IS IT < OR = "F" ?
	BHI INHEXL IF > IT AIN'T HEX
	SUBA #$37 ASCII ADJ. ALPHA
	RTS

INHEXL CMPA #'a IS IT > OR = "a"
	BCS NOTHEX IF LESS IT AIN'T HEX
	CMPA #'f IS IT < "f"
	BHI NOTHEX IF > IT AIN'T HEX
	SUBA #$57 ADJUST TO LOWER CASE
	RTS

NOTHEX ORCC #2 SET (V) FLAG IN C-CODES REGISTER
	RTS


OUT4H PSHS X PUSH X-REG. ON THE STACK
	PULS A POP MS BYTE OF X-REG INTO A-ACC.
	BSR OUTHL OUTPUT HEX LEFT
	PULS A POP LS BYTE OF X-REG INTO A-ACC.
OUTHL EQU *
OUT2H PSHS A SAVE IT BACK ON STACK
	LSRA CONVERT UPPER HEX NIBBLE TO ASCII
	LSRA
	LSRA
	LSRA
	BSR XASCII PRINT HEX NIBBLE AS ASCII
OUTHR PULS A CONVERT LOWER HEX NIBBLE TO ASCII
	ANDA #$0F STRIP LEFT NIBBLE
XASCII ADDA #$30 ASCII ADJ
	CMPA #$39 IS IT < OR = "9" ?
	BLE  OUTC IF LESS, OUTPUT IT
	ADDA #7 IF > MAKE ASCII LETTER
OUTC BRA  OUTCH OUTPUT CHAR


* BINARY / ASCII --- THIS ROUTINE
* OUTPUTS A BYTE IN ENHANCED
* BINARY FORMAT. THE ENHANCEMENT
* IS DONE BY SUBSTITUTING ASCII
* LETTERS FOR THE ONES IN THE BYTE.
* THE ASCII ENHANCEMENT LETTERS
* ARE OBTAINED FROM THE STRING
* POINTED TO BY THE INDEX REG. "X".

BIASCI PSHS A SAVE "A" ON STACK
	LDB  #8 PRESET LOOP# TO BITS PER BYTE
OUTBA LDA ,X+ GET LETTER FROM STRING
	ASL  ,S TEST BYTE FOR "1" IN B7
	BCS PRTBA IF ONE PRINT LETTER
	LDA #'- IF ZERO PRINT "-"
PRTBA BSR OUTCH PRINT IT
	BSR OUT1S PRINT SPACE
	DECB SUB 1 FROM #BITS YET TO PRINT
	BNE OUTBA
	PULS A
	RTS


* PRINT STRING PRECEEDED BY A CR & LF.

PSTRNG BSR PCRLF PRINT CR/LF
	BRA  PDATA  PRINT STRING POINTED TO BY IX

* PCRLF

PCRLF PSHS X SAVE IX
	LDX  #MSG2+1  POINT TO MSG CR/LF + 3 NULS
	BSR PDATA  PRINT MSG
	PULS X RESTORE IX
	RTS
PRINT BSR OUTCH


* PDATA

PDATA LDA  ,X+ GET 1st CHAR. TO PRINT
	CMPA #4 IS IT EOT?
	BNE  PRINT IF NOT EOT PRINT IT
	RTS


ECHON TST  ECHO IS ECHO REQUIRED ?
	BEQ  INCH ECHO NOT REQ. IF CLEAR


* INCHE

* ---GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.

INCHE BSR INCH GET CHAR FROM TERMINAL
	ANDA #$7F      STRIP PARITY FROM CHAR.
	BRA  OUTCH     ECHO CHAR TO TERMINAL


* INCH

* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.

INCH	pshs x
	ldx  CPORT
	lda  SRA,x
	bita #16	* Overrun?
	beq  GETSTAZ	* No, go ahead
	lda  #64	* clear errors command
	sta  CRA,x
GETSTA	lda  SRA,x
GETSTAZ	bita #1		* Character ready?
	beq  GETSTA	* bit not set, no character ready
	lda  RHRA,x
	puls x
	rts


* INCHEK

* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.


INCHEK	PSHS A,X 
	LDX  CPORT	* Get IO page
	lda  SRA,X	* FETCH PORT STATUS
	BITA #1		* TEST READY BIT, rxrdy ?
	PULS A,X
	RTS

OUT2S BSR OUT1S OUTPUT 2 SPACES
OUT1S LDA  #$20  OUTPUT 1 SPACE


* OUTCH

* OUTPUT CHARACTER TO TERMINAL.
* THE CHAR. TO BE OUTPUT IS
* PASSED IN THE A REGISTER.
* ALL REGISTERS ARE PRESERVED.

OUTCH	pshs a,x
	ldx  CPORT
FETSTA	lda  SRA,x
	BITA #4		* tx buffer full?
	beq FETSTA
	puls a
	sta THRA,x	* Send char out
	puls x
	rts


*** DUART INIT from David's prototype built on a Grant Searle 6809 SBC

CONINIZ	ldx CPORT
	lda #16		* Reset mode register A
	sta CRA,x
	lda #19		* 8 bits no parity no flow control no irq
	sta ,x		* mr1a
	lda #7		* Normal mode, 1.00 stop bits
	sta ,x		* mr2a
	lda #32		* RX reset
	sta CRA,x
	lda #48		* TX reset
	sta CRA,x
	lda #%10111011	* 9600bps tx,rx
	sta CSRA,x
	lda #69		* Reset errors, enable rx,tx
	sta CRA,x
	rts		* DUART online!

* MONITOR KEYBOARD COMMAND JUMP TABLE


JMPTAB EQU *
	FCB 1		*" ^A "
	FDB ALTRA
	FCB 2		*" ^B "
	FDB ALTRB
	FCB 3		*" ^C "
	FDB ALTRCC
	FCB 4		*" ^D "
	FDB ALTRDP
	FCB $10		*" ^P "
	FDB ALTRPC
	FCB $15		*" ^U "
	FDB ALTRU
	FCB $18		*" ^X "
	FDB ALTRX
	FCB $19		*" ^Y "
	FDB ALTRY
	FCC 'B'
	FDB BRKPNT
	FCC 'E'
	FDB MEMDUMP
	FCC 'G'
	FDB GO
	FCC 'L'
	FDB LOAD
	FCC 'M'
	FDB MEMCHG
	FCC 'P'
	FDB PUNCH
	FCC 'Q'
	FDB MEMTST
	FCC 'R'
	FDB REGSTR
	FCC 'K'
	FDB DISSTK
	FCC 'S'
	FDB LOADS	* Start loading s19 file without typing L
	FCC 'X'
	FDB XBKPNT
TABEND EQU *

* ** 6809 VECTOR ADDRESSES **

* FOLLOWING ARE THE ADDRESSES OF THE VECTOR ROUTINES
* FOR THE 6809 PROCESSOR. DURING INITIALIZATION THEY
* ARE RELOCATED TO RAM FROM $DFC0 TO $DFCF. THEY ARE
* RELOCATED TO RAM SO THAT THE USER MAY REVECTOR TO
* HIS OWN ROUTINES IF HE SO DESIRES.


RAMVEC FDB SWIE  USER-V
	FDB RTI    SWI3-V
	FDB RTI    SWI2-V
	FDB RTI    FIRQ-V
	FDB RTI    IRQ-V
	FDB SWIE   SWI-V
	FDB $FFFF  SVC-VO
	FDB $FFFF  SVC-VL

* PRINTABLE MESSAGE STRINGS

MSG1 FCB $0,$0,$0,$D,$A,$0,$0,$0 	* 0, CR/LF, 0
	FCC 'S-BUG 1.8 - 6809v2 port jbevren 2018 '
	FCB $D, $A
	FCB 4
MSG2 FCB 'K,$D,$A,$0,$0,$0,4 K, 	* CR/LF + 3 NULS
MSG3 FCC '>'
	FCB 4
MSG4 FCC 'WHAT?'
	FCB 4
MSG5 FCC ' - '
	FCB 4
MSG6 FCC ', PASS '
	FCB 4
MSG7 FCC ', BITS IN ERROR: '
	FCB 4
MSG8 FCC ' => '
	FCB 4
MSG9 FCC '76543210'
MSG10 FCC '  SP='
	FCB 4
MSG11 FCC '  PC='
	FCB 4
MSG12 FCC '  US='
	FCB 4
MSG13 FCC '  IY='
	FCB 4
MSG14 FCC '  IX='
	FCB 4
MSG15 FCC '  DP='
	FCB 4
MSG16 FCC '  A='
	FCB 4
MSG17 FCC '  B='
	FCB 4
MSG18 FCC '  CC: '
	FCB 4
MSG19 FCC 'EFHINZVC'
MSG20 FCC 'S1'
	FCB 4


*** POWER UP/ RESET/ NMI ENTRY POINT

START 
	LDS  #STACK INITIALIZE STACK POINTER
	LDA  #$01  SET "A" NON-ZERO
	STA  ECHO TURN ON ECHO FLAG
	LBRA MONITOR INITIALIZATION IS COMPLETE


V1 JMP  [STACK]
V2 JMP  [SWI2]
V3 JMP  [FIRQ]
V4 JMP  [IRQ]
V5 JMP  [SWI]

* SWI3 ENTRY POINT

SWI3E TFR  S,U
	LDX  10,U      *$FFC8
	LDB  ,X+
	STX  10,U
	CLRA
	ASLB
	ROLA
	LDX  SVCVO
	CMPX #$FFFF
	BEQ  SWI3Z
	LEAX D,X
	CMPX SVCVL
	BHI  SWI3Z
	PSHS X
	LDD  ,U
	LDX  4,U
	JMP  [,S++]
SWI3Z PULU A,B,X,CC,DP
	LDU  2,U
	JMP  [SWI3]

* BIG FAT NOTE:
*  don't allow code at ff00-ffdf on the 6809v2 hardware
*  as that's the IO page for that system

* 6809 VECTORS

	ORG $FFF0

	FDB V1    USER-V
	FDB SWI3E SWI3-V
	FDB V2    SWI2-V
	FDB V3    FIRQ-V
	FDB V4    IRQ-V
	FDB V5    SWI-V
	FDB V1    NMI-V
	FDB START RESTART-V
	END


